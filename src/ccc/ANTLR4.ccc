DEFAULT_LEXICAL_STATE=ANTLR;
TAB_SIZE=4;
ENSURE_FINAL_EOL;

INCLUDE "ANTLR4Lexer.ccc"

INJECT PARSER_CLASS :
   import java.nio.file.FileSystems;
{
   static public void main(String[] args) {
     if (args.length == 0) {
      usage();
      return;
     }
     int successfulParses = 0;
     int unsuccessfulParses = 0;
     for (int i = 0;i<args.length;i++) {
        try {
           Node root = parseFile(args[i]);
           System.out.println("Parsed " + args[i] + " successfully.");
           if (args.length == 1) root.dump();
           successfulParses++;
        } catch (Exception e) {
           System.out.println("Failed on " + args[i]);
           e.printStackTrace();
           unsuccessfulParses++;
        }
     }
     System.out.println("Successfully parsed " + successfulParses + " files.");
     System.out.println("Failed on " + unsuccessfulParses + " files.");
   }

   static Node parseFile(String name) throws IOException {
     Path path = FileSystems.getDefault().getPath(name);
     PARSER_CLASS parser = new PARSER_CLASS(path);
     parser.GrammarSpec();
     return parser.rootNode();
     //Node root = parser.rootNode();
     //root.dump();
   }

   static void usage() {
      System.out.println("java Antlr4Parser <FILENAME>");
   }
}

GrammarSpec :
    GrammarDecl
    (PrequelConstruct)*
    (LexerRuleSpec | ParserRuleSpec)*
//    (ParserRuleSpec | LexerRuleSpec)*
    (ModeSpec)*
    <EOF>
;    

GrammarDecl :
    GrammarType
    <IDENTIFIER>
    <SEMICOLON>
;    

GrammarType :
    [<LEXER>|<PARSER>] <GRAMMAR>
;

PrequelConstruct :
    OptionsSpec
    |
    DelegateGrammars
    |
    TokensSpec
    |
    ChannelsSpec
    |
    Action_
;

OptionsSpec:
    <OPTIONS>
    (Option <SEMICOLON>)*
    <RBRACE>
;

Option :
    <IDENTIFIER>
    <ASSIGN>
    OptionValue
;    

OptionValue :
    <IDENTIFIER>
    |
    <STRING_LITERAL>
    |
    ActionBlock
    |
    <INT>
;

DelegateGrammars :
    <IMPORT>
    DelegateGrammar
    (<COMMA> DelegateGrammar)*
    <SEMICOLON>
;    

DelegateGrammar :
   <IDENTIFIER> [<ASSIGN> <IDENTIFIER>]
;   

IdList :
   <IDENTIFIER> (<COMMA> <IDENTIFIER> =>||)* [<COMMA>]
;

TokensSpec :
   <TOKENS> IdList <RBRACE>
;

ChannelsSpec :
   <CHANNELS> [IdList] <RBRACE>
;

ModeSpec :
   <MODE> <IDENTIFIER> <SEMICOLON> (LexerRuleSpec)*
;

ParserRuleSpec :
   [RuleModifiers]
   <IDENTIFIER>
   ENSURE {Character.isUpperCase(getToken(0).charAt(0))}
   [ArgActionBlock]
   [RuleReturns]
   [ThrowsSpec]
   [LocalsSpec]
   (RulePrequel)*
   <COLON>
   RuleBlock
   <SEMICOLON>
   ExceptionGroup
;

LexerRuleSpec :
    [<FRAGMENT>]
    <IDENTIFIER>
    ENSURE {Character.isUpperCase(getToken(0).charAt(0))}
    =>||
    [OptionsSpec]
    <COLON>
    LexerRuleBlock
    <SEMICOLON>
;    

Action_ :
   <AT> [ActionScopeName <DOUBLE_COLON>] <IDENTIFIER> ActionBlock
;

ActionScopeName :
    <IDENTIFIER>|<LEXER>|<PARSER>
;

ActionBlock :
    <LBRACE> {token_source.setActionBlockStart(1+lastConsumedToken.getBeginOffset());}
    LEXICAL_STATE IN_ACTION_BLOCK (<ACTION>)
    <RBRACE>
;

ArgActionBlock :
    <LBRACKET>
    // REVISIT: Need a lexical state change
    // TODO: Need a bit of fancy lexical stuff
    //(<ARGUMENT_CONTENT>)*
    <RBRACKET>
;

ExceptionGroup :
   (ExceptionHandler)* [FinallyClause]
;   

ExceptionHandler :
   <CATCH>
   ArgActionBlock
   ActionBlock
;

FinallyClause :
   <FINALLY> ActionBlock
;

RulePrequel :
   OptionsSpec | RuleAction
;

ThrowsSpec :
    <THROWS>
    <IDENTIFIER>
    (<COMMA> <IDENTIFIER>)*
;

LocalsSpec :
   <LOCALS> ArgActionBlock
;

RuleAction :
   <AT> <IDENTIFIER> ActionBlock
;

RuleReturns :
    <RETURNS> ArgActionBlock
;

RuleModifiers :
    (<PUBLIC>|<PRIVATE>|<PROTECTED>|<FRAGMENT>)+
;

RuleBlock :
    LabeledAlt (<OR>LabeledAlt)*
;

LabeledAlt :
    Alternative [<POUND><IDENTIFIER>]
;

Alternative :
   [ElementOptions] (Element)*
;

AltList :
   Alternative (<OR> Alternative)*
;

LexerRuleBlock :
   LexerAlt (<OR> LexerAlt)*
;

LexerAlt :
   [(LexerElement)+ [LexerCommands]]
; 

LexerElement :
   LabeledLexerElement [EbnfSuffix]
   |
   LexerAtom [EbnfSuffix]
   |
   LexerBlock [EbnfSuffix]
   |
   ActionBlock [<QUESTION>]
;
    
EbnfSuffix :
   <QUESTION> [<QUESTION>]
   | 
   <STAR> [<QUESTION>]
   | 
   <PLUS> [<QUESTION>]
;

LexerBlock :
   <LPAREN> LexerRuleBlock <RPAREN>
;

CharacterRange :
   <STRING_LITERAL> <RANGE> =>|| <STRING_LITERAL>
;   

Terminal :
   <IDENTIFIER> [ElementOptions]
   |
   <STRING_LITERAL> [ElementOptions]
 ;

ElementOptions :
   <LT> ElementOption (<COMMA> ElementOption)* <GT>
;

ElementOption : 
   <IDENTIFIER> [<ASSIGN> (<IDENTIFIER> | <STRING_LITERAL>)]
;

LexerAtom : 
   CharacterRange
   | 
   Terminal
   | 
   NotSet
   |
   LexerCharSet
   | 
   <DOT> [ElementOptions]
;

LexerCharSet :
   <LBRACKET>
   LEXICAL_STATE IN_LEXER_CHAR_SET (<CONTENT>)
   <RBRACKET>
;   

NotSet : 
   <NOT> (SetElement | BlockSet)
;

BlockSet : 
   <LPAREN> SetElement (<OR> SetElement)* <RPAREN>
;

SetElement : 
   <IDENTIFIER> [ElementOptions]
   | 
   CharacterRange
   | 
   <STRING_LITERAL> [ElementOptions]
   |
   LexerCharSet
;

Element : 
   LabeledElement [EbnfSuffix]
   | 
   Atom [EbnfSuffix]
   | 
   Ebnf
   | 
   ActionBlock <QUESTION>
;

LabeledElement : 
    <IDENTIFIER> (<ASSIGN> | <PLUS_ASSIGN>) =>|| (Atom | Block)
;

Atom :
   Ruleref
   | 
   Terminal
   | 
   NotSet
   | 
   <DOT> [ElementOptions]
;

Ebnf : 
   Block [EbnfSuffix]
;

Ruleref : 
   <IDENTIFIER> [ArgActionBlock] [ElementOptions]
;

Block : 
   <LPAREN> 
   [[OptionsSpec] (RuleAction)* <COLON>] AltList 
   <RPAREN>
;

LexerCommand :
  (<IDENTIFIER>|<MODE>) [<LPAREN> (<IDENTIFIER>|<INT>) <RPAREN>]
;

LabeledLexerElement :
   <IDENTIFIER> (<ASSIGN> | <PLUS_ASSIGN>) =>|| (LexerAtom | LexerBlock)
;

LexerCommands : 
   <RARROW> LexerCommand (<COMMA> LexerCommand)*
;
