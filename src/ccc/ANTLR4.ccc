DEFAULT_LEXICAL_STATE=ANTLR;
TAB_SIZE=4;
ENSURE_FINAL_EOL;

INCLUDE "ANTLR4Lexer.ccc"

GrammarSpec :
    GrammarDecl
    (PrequelConstruct)*
    (ParserRuleSpec | LexerRuleSpec)*
    (ModeSpec)*
    <EOF>
;    

GrammarDecl :
    GrammarType
    <IDENTIFIER>
    <SEMICOLON>
;    

GrammarType :
    [<LEXER>|<PARSER>] <GRAMMAR>
;

PrequelConstruct :
    OptionsSpec
    |
    DelegateGrammars
    |
    TokensSpec
    |
    ChannelsSpec
    |
    Action_
;

OptionsSpec:
    <OPTIONS>
    (Option <SEMICOLON>)
    <RBRACE>
;

Option :
    <IDENTIFIER>
    <ASSIGN>
    OptionValue
;    

OptionValue :
    <IDENTIFIER>
    |
    <STRING_LITERAL>
    |
    ActionBlock
    |
    <INT>
;

DelegateGrammars :
    <IMPORT>
    DelegateGrammar
    (<COMMA> DelegateGrammar)*
    <SEMICOLON>
;    

DelegateGrammar :
   <IDENTIFIER> [<ASSIGN> <IDENTIFIER>]
;   

IdList :
   <IDENTIFIER> (<COMMA> <IDENTIFIER> =>||) [<COMMA>]
;

TokensSpec :
   <TOKENS> IdList <RBRACE>
;

ChannelsSpec :
   <CHANNELS> [IdList] <RBRACE>
;

ModeSpec :
   <MODE> <IDENTIFIER> <SEMICOLON> (LexerRuleSpec)*
;

ParserRuleSpec :
   [RuleModifiers]
   <IDENTIFIER>
   [ArgActionBlock]
   [RuleReturns]
   [ThrowsSpec]
   [LocalsSpec]
   (RulePrequel)*
   <COLON>
   RuleBlock
   <SEMICOLON>
   ExceptionGroup
;

Action_ :
   <AT> [ActionScopeName <COLONCOLON>] <IDENTIFIER> ActionBlock
;

ActionScopeName :
    <IDENTIFIER>|<LEXER>|<PARSER>
;

ActionBlock :
    <BEGIN_ACTION>
    (<ACTION_CONTENT>)*
    <END_ACTION>
;

ArgActionBlock :
    <BEGIN_ARGUMENT>
    (<ARGUMENT_CONTENT>)*
    <END_ARGUMENT>
;

ExceptionGroup :
   (ExceptionHandler)* [FinallyClause]
;   

ExceptionHandler :
   <CATCH>
   ArgActionBlock
   ActionBlock
;

FinallyClause :
   <FINALLY> ActionBlock
;

RulePrequel :
   OptionsSpec | RuleAction
;

ThrowsSpec :
    <THROWS>
    <IDENTIFIER>
    (<COMMA> <IDENTIFIER>)*
;

LocalsSpec :
   <LOCALS> ArgActionBlock
;

RuleAction :
   <AT> <IDENTIFIER> ActionBlock
;

RuleReturns :
    <RETURNS> ArgActionBlock
;

RuleModifiers :
    (<PUBLIC>|<PRIVATE>|<PROTECTED>|<FRAGMENT>)+
;

LexerRuleSpec :
    [<FRAGMENT>]
    <IDENTIFIER>
    [OptionsSpec]
    <COLON>
    LexerRuleBlock
    <SEMICOLON>
;    

RuleBlock :
    LabeledAlt (<OR>LabeledAlt)*
;

LabeledAlt :
    Alternative [<POUND><IDENTIFIER>]
;

Alternative :
   [ElementOptions] (Element)*
; 

LexerRuleBlock :
   LexerAlt (<OR> LexerAlt)*
;

LexerAlt :
   [LexerElements [LexerCommands]]
;   
    

#if false

lexerElements
   : lexerElement+
   |
   ;

lexerElement
   : labeledLexerElement ebnfSuffix?
   | lexerAtom ebnfSuffix?
   | lexerBlock ebnfSuffix?
   | actionBlock QUESTION?
   ;
   // but preds can be anywhere

labeledLexerElement
   : identifier (ASSIGN | PLUS_ASSIGN) (lexerAtom | lexerBlock)
   ;

lexerBlock
   : LPAREN lexerAltList RPAREN
   ;
   // E.g., channel(HIDDEN), skip, more, mode(INSIDE), push(INSIDE), pop

lexerCommands
   : RARROW lexerCommand (COMMA lexerCommand)*
   ;

lexerCommand
   : lexerCommandName LPAREN lexerCommandExpr RPAREN
   | lexerCommandName
   ;

lexerCommandName
   : identifier
   | MODE
   ;

lexerCommandExpr
   : identifier
   | INT
   ;
   // --------------------
   // Rule Alts

altList
   : alternative (OR alternative)*
   ;


element
   : labeledElement (ebnfSuffix |)
   | atom (ebnfSuffix |)
   | ebnf
   | actionBlock QUESTION?
   ;

labeledElement
   : identifier (ASSIGN | PLUS_ASSIGN) (atom | block)
   ;
   // --------------------
   // EBNF and blocks

ebnf
   : block blockSuffix?
   ;

blockSuffix
   : ebnfSuffix
   ;

ebnfSuffix
   : QUESTION QUESTION?
   | STAR QUESTION?
   | PLUS QUESTION?
   ;

lexerAtom
   : characterRange
   | terminal
   | notSet
   | LEXER_CHAR_SET
   | DOT elementOptions?
   ;

atom
   : terminal
   | ruleref
   | notSet
   | DOT elementOptions?
   ;

// --------------------
// Inverted element set
notSet
   : NOT setElement
   | NOT blockSet
   ;

blockSet
   : LPAREN setElement (OR setElement)* RPAREN
   ;

setElement
   : TOKEN_REF elementOptions?
   | STRING_LITERAL elementOptions?
   | characterRange
   | LEXER_CHAR_SET
   ;

// -------------
// Grammar Block
block
   : LPAREN (optionsSpec? ruleAction* COLON)? altList RPAREN
   ;

// ----------------
// Parser rule ref
ruleref
   : RULE_REF argActionBlock? elementOptions?
   ;

// ---------------
// Character Range
characterRange
   : STRING_LITERAL RANGE STRING_LITERAL
   ;

terminal
   : TOKEN_REF elementOptions?
   | STRING_LITERAL elementOptions?
   ;

// Terminals may be adorned with certain options when
// reference in the grammar: TOK<,,,>
elementOptions
   : LT elementOption (COMMA elementOption)* GT
   ;

elementOption
   : identifier
   | identifier ASSIGN (identifier | STRING_LITERAL)
   ;

#endif